#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
#
# This script configures periodic S.M.A.R.T tests and monitoring

###################
## SMARTD CONFIG ##
###################
# See: https://linux.die.net/man/5/smartd.conf
# 
# Enable common directives
# Skip if asleep, up to 4 times
# Supress messages when skipped
# Run short test daily at 22h00
# Run long test monthly on the 1st at 00h00
SD_SMARTD_CONF="DEVICESCAN -a -n sleep,4,q -s (S/../.././22|L/../01/./00)"

sd_configure() {
  if [[ -z "${BIN_DIR}" ]]; then
    logError "BIN_DIR is not set"
    return 1
  fi
  if [[ -z "${CONFIG_DIR}" ]]; then
    logError "CONFIG_DIR is not set"
    return 1
  fi

  # Load email configuration
  local cfg_email="${CONFIG_DIR}/email.env"
  if ! config_load "${cfg_email}"; then
    logError "Failed to load email configuration"
    return 1
  fi
  
  # Script to execute on SMART events
  local file
  file=$(cat <<EOF
#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
#
# Scripts that handles events generated by smartd
# (This file was automatically generated during installation)

# Import email configuration
source "${cfg_email}"
source "${SETUP_REPO_DIR}/src/slf4sh.sh"

SEND_XCP="true"
if ! command -v xe &>/dev/null; then
  logError "XCP-ng not detected"
  SEND_XCP=""
fi

if ! res=\$(xe host-list name-label=\$(hostname) --minimal); then
  logError "Failed to get host"
  SEND_XCP=""
elif [[ -z "\${res}" ]]; then
  logError "Host not found"
  SEND_XCP=""
elif [[ "\${res}" == *","* ]]; then
  logError "Multiple hosts found"
  SEND_XCP=""
else
  HOST_ID=\${res}
fi

# XCP-ng message levels
LVL_ERROR=1
LVL_WARN=2
LVL_INFO=3
LVL_DEBUG=4
LVL_TRACE=5

# Prepare event message
DEV_MSG="\$(/usr/sbin/smartctl -a "\${SMARTD_DEVICE}")"
if [[ \$? -ne 0 ]]; then
  logWarn "Failed to get SMART status for \${SMARTD_DEVICE}"
  DEV_MSG="Failed to get SMART status for \${SMARTD_DEVICE}"
fi

# Check if this drive is part of a RAID array
if [[ -f /proc/mdstat ]]; then
  if RAID_ARRAY=\$(grep -w "\$(basename \${SMARTD_DEVICE}).*" /proc/mdstat); then
    RAID_ARRAY="/dev/\$(echo "\${RAID_ARRAY}" | awk '{print \$1}')"
    logInfo "Drive \${SMARTD_DEVICE} is part of RAID array: \${RAID_ARRAY}"
  else
    RAID_ARRAY=""
    logInfo "Drive \${SMARTD_DEVICE} is not part of a RAID array"
  fi
fi

if [[ -z "\${RAID_ARRAY}" ]]; then
  RAID_MSG="Drive \${SMARTD_DEVICE} is not part of a RAID array"
else
  RAID_MSG=\$(cat <<END
Drive \${SMARTD_DEVICE} is part of RAID array: \${RAID_ARRAY}

\$(/usr/sbin/mdadm --detail \${RAID_ARRAY})
END
)
fi

SUBJECT="[\$(hostname)] SMART - \${SMARTD_MESSAGE}"
MESSAGE=\$(cat <<END

Subject: \${SUBJECT}

Arguments: (\$#):"
\$(for arg in "\$@"; do echo "  \${arg}"; done)

\${SMARTD_FULLMESSAGE}

SMARTD_MAILER: "\${SMARTD_MAILER}"
SMARTD_DEVICE: "\${SMARTD_DEVICE}"
SMARTD_DEVICETYPE: "\${SMARTD_DEVICETYPE}"
SMARTD_DEVICESTRING: "\${SMARTD_DEVICESTRING}"
SMARTD_FAILTYPE: "\${SMARTD_FAILTYPE}"
SMARTD_ADDRESS: "\${SMARTD_ADDRESS}"
SMARTD_MESSAGE: "\${SMARTD_MESSAGE}"
SMARTD_TFIRST: "\${SMARTD_TFIRST}"
SMARTD_TFIRSTEPOCH: "\${SMARTD_TFIRSTEPOCH}"

Current SMART status for "\${SMARTD_DEVICE}:"

\${DEV_MSG}

\${RAID_MSG}
END
)

# Logging it
logInfo <<END
Logging a SMART event:

\${MESSAGE}
END

# Send an email
echo "\${MESSAGE}" | \${MAIL_CMD} -s "\${SUBJECT}" -r \${SENDER} \${SYSADMIN}
if [[ \$? -ne 0 ]]; then
  logError "Failed to send SMART email"
  SEND_XCP=""
else
  logInfo "SMART email sent succesfully"
fi

# Send warning to XCP-ng
if [[ -z "\${SEND_XCP}" ]]; then
  logWarn "Skipping XCP-ng notification"
else
  xe message-create name="SMART" body="\${SMARTD_MESSAGE}" priority=\$LVL_WARN host-uuid=\${HOST_ID}
  if [[ \$? -ne 0 ]]; then
    logError "Failed to send SMART notification to XCP-ng"
  else
    logInfo "SMART notification sent to XCP-ng"
  fi
fi

if [[ -z "\${SEND_XCP}" ]]; then
  exit 1
else
  exit 0
fi

EOF
)

  # There's a bug if the filename contains a dot: https://askubuntu.com/a/1058433
  local smart_file="${BIN_DIR}/smartd_event"
  logInfo "Installing SMART event script"
  echo "${file}" > "${smart_file}"
  if [[ $? -ne 0 ]]; then
    logWarn "Failed to install smartd event script"
  fi
  chmod +x "${smart_file}"
  if [[ $? -ne 0 ]]; then
    logWarn "Failed to make smartd event script executable"
  fi

  # Configure smartd
  local cfg_file="/etc/smartmontools/smartd.conf"
  local cfg_file_backp="${cfg_file}.bak"

  if [[ -f "${cfg_file}" ]]; then
    if [[ ! -f "${cfg_file_backp}" ]]; then
      cp "${cfg_file}" "${cfg_file_backp}"
    fi
  else
    logWarn "smartd configuration was not found"
  fi

  local cfg_line="${SD_SMARTD_CONF} -m ${SYSADMIN} -M exec ${smart_file}"
  if ! grep -q "^${cfg_line}\$" "${cfg_file}"; then
    if grep -q "^DEVICESCAN.*" "${cfg_file}"; then
      sed -i "s=^DEVICESCAN.*=${cfg_line}=" "${cfg_file}"
      logInfo "Updated smartd configuration"
    else
      echo "${cfg_line}" >> "${cfg_file}"
      logInfo "Appended smartd configuration"
    fi
    sd_restart
  else
    logInfo "smartd already configured"
  fi
  return $?
}

sd_restart() {
  logInfo "Restarting smartd..."
  systemctl restart smartd
  if [[ $? -ne 0 ]]; then
    logError "Failed to restart smartd"
    return 1
  else 
    logInfo "Restarted smartd"
  fi
  return 0
}

sd_test_alerts() {
  # Append to cfg_line for a test
  local cfg_file="/etc/smartmontools/smartd.conf"
  local cfg_line
  local cfg_line_orig

  if [[ -f "${cfg_file}" ]]; then
    cfg_line_orig=$(grep -E "^DEVICESCAN" "${cfg_file}")
    if [[ $? -ne 0 ]]; then
      logError "Failed to read smartd configuration"
      return 1
    fi
    cfg_line="${cfg_line_orig} -M test"
    sed -i "s=^DEVICESCAN.*=${cfg_line}=" "${cfg_file}"
    if [[ $? -ne 0 ]]; then
      logError "Failed to to configure samrtd for testing"
      return 1
    fi
    logInfo "Appended test to smartd configuration"
  else
    logError "smartd configuration was not found"
    return 1
  fi

  logInfo "Lauching test..."
  sd_restart
  if [[ $? -ne 0 ]]; then
    logWarn "Failed to restart smartd for conducting the test"
  else
    logInfo "Test successful. Restoring smartd configuration..."
  fi
  
  # Restore original configuration
  local success
  sed -i "s=^DEVICESCAN.*=${cfg_line_orig}=" "${cfg_file}"
  success=$?
  if [[ $success -ne 0 ]]; then
    logError "Failed to restore smartd configuration"
  fi

  if ! sd_restart; then
    success=1
  fi

  return $success
}

###########################
###### Startup logic ######
###########################
SD_ARGS=("$@")
SD_CWD=$(pwd)
SD_ME="$(basename "$0")"

# Get directory of this script
# https://stackoverflow.com/a/246128
SD_SOURCE=${BASH_SOURCE[0]}
while [[ -L "${SD_SOURCE}" ]]; do # resolve $SD_SOURCE until the file is no longer a symlink
  SD_ROOT=$(cd -P "$(dirname "${SD_SOURCE}")" >/dev/null 2>&1 && pwd)
  SD_SOURCE=$(readlink "${SD_SOURCE}")
  [[ ${SD_SOURCE} != /* ]] && SD_SOURCE=${SD_ROOT}/${SD_SOURCE} # if $SD_SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
SD_ROOT=$(cd -P "$(dirname "${SD_SOURCE}")" >/dev/null 2>&1 && pwd)
SD_ROOT=$(realpath "${SD_ROOT}/../..")

# Import dependencies
SETUP_REPO_DIR="${SD_ROOT}/external/setup"
source ${SETUP_REPO_DIR}/src/slf4sh.sh
source ${SETUP_REPO_DIR}/src/config.sh

if [[ -p /dev/stdin ]] && [[ -z ${BASH_SOURCE[0]} ]]; then
  # This script was piped
  echo "ERROR: This script cannot be piped"
  exit 1
elif [[ ${BASH_SOURCE[0]} != "${0}" ]]; then
  # This script was sourced
  :
else
  # This script was executed
  # sd_configure
  sd_test_alerts
fi
