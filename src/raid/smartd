#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
#
# This script configures periodic S.M.A.R.T tests and monitoring

###################
## SMARTD CONFIG ##
###################
# See: https://linux.die.net/man/5/smartd.conf
#
# Enable common directives
# Skip if asleep, up to 4 times
# Supress messages when skipped
# Run short test daily at 22h00
# Run long test monthly on the 1st at 00h00
SD_SMARTD_CONF="-a -n sleep,4,q -s (S/../.././22|L/../01/./00)"

# TODO: I'm missing 3 drives not being monitored: sdg, nvme0n1 nvmm1n1
# We can accomplish this by comparing the output of `smartctl --scan` with the output of `lsblk -o NAME,TYPE`

sd_configure() {
  if [[ -z "${BIN_DIR}" ]]; then
    logError "BIN_DIR is not set"
    return 1
  fi
  if [[ -z "${CONFIG_DIR}" ]]; then
    logError "CONFIG_DIR is not set"
    return 1
  fi

  # Load email configuration
  local cfg_email="${CONFIG_DIR}/email.env"
  if ! config_load "${cfg_email}"; then
    logError "Failed to load email configuration"
    return 1
  fi

  # Script to execute on SMART events
  local file
  file=$(
    cat <<EOF
#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
#
# Scripts that handles events generated by smartd
# (This file was automatically generated during installation)

# Determine BPKG's global prefix
if [[ -z "\${PREFIX}" ]]; then
  if [[ \$(id -u || true) -eq 0 ]]; then
    PREFIX="/usr/local"
  else
    PREFIX="\${HOME}/.local"
  fi
fi

if ! source "\${PREFIX}/lib/slf4.sh"; then
  echo "Failed to import slf4.sh"
  exit 1
fi
if ! source "${SD_ROOT}/external/xapi.sh/src/xe_utils.sh"; then
  logFatal "Failed to import xe_utils.sh"
fi
# Import email configuration
if ! source "${cfg_email}"; then
  logFatal "Failed to load email configuration"
fi

SEND_XCP="true"
if ! xe exec res host-list name-label=\$(hostname) --minimal; then
  logError "Failed to get host"
  SEND_XCP=""
elif [[ -z "\${res}" ]]; then
  logError "Host not found"
  SEND_XCP=""
elif [[ "\${res}" == *","* ]]; then
  logError "Multiple hosts found"
  SEND_XCP=""
else
  HOST_ID=\${res}
fi

# XCP-ng message levels
LVL_ERROR=1
LVL_WARN=2
LVL_INFO=3
LVL_DEBUG=4
LVL_TRACE=5

# Prepare event message
if [[ "\${SMARTD_DEVICE}" == "/dev/sd"* ]]; then
  DEV_MSG="\$(/usr/sbin/smartctl -a -d scsi "\${SMARTD_DEVICE}")"
  res=\$?
elif [[ "\${SMARTD_DEVICE}" == "/dev/nvme"* ]]; then
  DEV_MSG="\$(/usr/sbin/smartctl -a -d nvme "\${SMARTD_DEVICE}")"
  res=\$?
else
  DEV_MSG="\$(/usr/sbin/smartctl -a "\${SMARTD_DEVICE}")"
  res=\$?
fi
if [[ \${res} -ne 0 ]]; then
  logWarn "Failed to get SMART status for \${SMARTD_DEVICE}\${IFS}\${DEV_MSG}"
  DEV_MSG="Failed to get SMART status for \${SMARTD_DEVICE}\${IFS}\${DEV_MSG}"
fi

# Check if this drive is part of a RAID array
if [[ -f /proc/mdstat ]]; then
  if RAID_ARRAY=\$(grep -w "\$(basename \${SMARTD_DEVICE}).*" /proc/mdstat); then
    RAID_ARRAY="/dev/\$(echo "\${RAID_ARRAY}" | awk '{print \$1}')"
    logInfo "Drive \${SMARTD_DEVICE} is part of RAID array: \${RAID_ARRAY}"
  else
    RAID_ARRAY=""
    logInfo "Drive \${SMARTD_DEVICE} is not part of a RAID array"
  fi
fi

if [[ -z "\${RAID_ARRAY}" ]]; then
  RAID_MSG="Drive \${SMARTD_DEVICE} is not part of a RAID array"
else
  RAID_MSG=\$(cat <<END
Drive \${SMARTD_DEVICE} is part of RAID array: \${RAID_ARRAY}

\$(/usr/sbin/mdadm --detail \${RAID_ARRAY})
END
)
fi

SUBJECT="[\${HOSTNAME}] SMART - \${SMARTD_FAILTYPE} on \${SMARTD_DEVICE}"
MESSAGE=\$(cat <<END

Subject: \${SUBJECT}

Arguments: (\$#):"
\$(for arg in "\$@"; do echo "  \${arg}"; done)

\${SMARTD_FULLMESSAGE}

SMARTD_MAILER: "\${SMARTD_MAILER}"
SMARTD_DEVICE: "\${SMARTD_DEVICE}"
SMARTD_DEVICETYPE: "\${SMARTD_DEVICETYPE}"
SMARTD_DEVICESTRING: "\${SMARTD_DEVICESTRING}"
SMARTD_FAILTYPE: "\${SMARTD_FAILTYPE}"
SMARTD_ADDRESS: "\${SMARTD_ADDRESS}"
SMARTD_MESSAGE: "\${SMARTD_MESSAGE}"
SMARTD_TFIRST: "\${SMARTD_TFIRST}"
SMARTD_TFIRSTEPOCH: "\${SMARTD_TFIRSTEPOCH}"

Current SMART status for "\${SMARTD_DEVICE}:"

\${DEV_MSG}

\${RAID_MSG}
END
)

# Logging it
logInfo <<END
Logging a SMART event:

\${MESSAGE}
END

# Send an email
echo "\${MESSAGE}" | \${MAIL_CMD} -s "\${SUBJECT}" -r \${SENDER} \${SYSADMIN}
if [[ \$? -ne 0 ]]; then
  logError "Failed to send SMART email"
  SEND_XCP=""
else
  logInfo "SMART email sent succesfully"
fi

# Send warning to XCP-ng
if [[ -z "\${SEND_XCP}" ]]; then
  logWarn "Skipping XCP-ng notification"
else
  xe_exec null message-create name="SMART" body="\${SMARTD_MESSAGE}" priority=\$LVL_WARN host-uuid=\${HOST_ID}
  if [[ \$? -ne 0 ]]; then
    logError "Failed to send SMART notification to XCP-ng"
  else
    logInfo "SMART notification sent to XCP-ng"
  fi
fi

if [[ -z "\${SEND_XCP}" ]]; then
  exit 1
else
  exit 0
fi

EOF
  )

  # There's a bug if the filename contains a dot: https://askubuntu.com/a/1058433
  local smart_file="${BIN_DIR}/smartd_event"
  logInfo "Installing SMART event script"
  if ! echo "${file}" >"${smart_file}"; then
    logWarn "Failed to install smartd event script"
  fi
  if ! chmod +x "${smart_file}"; then
    logWarn "Failed to make smartd event script executable"
  fi

  # Configure smartd
  local cfg_file="/etc/smartmontools/smartd.conf"
  local cfg_content
  if ! build_config_file cfg_content; then
    logError "Failed to build smartd configuration"
    return 1
  fi

  local cfg_file_backp="${cfg_file}.bak"
  if [[ -f "${cfg_file}" ]]; then
    if [[ ! -f "${cfg_file_backp}" ]]; then
      cp "${cfg_file}" "${cfg_file_backp}"
    fi
  else
    logWarn "smartd configuration was not found"
  fi

  # Append -m and -M opttions in cfg_content to the line containing DEFAULT
  if ! grep -q "^DEFAULT" <<<"${cfg_content}"; then
    logError "Failed to find DEFAULT directive in smartd configuration"
  else
    # shellcheck disable=SC2001
    cfg_content=$(sed "s|^DEFAULT.*|& -m ${SYSADMIN} -M exec ${smart_file}|" <<<"${cfg_content}")
  fi

  # Compare the current configuration file with cfg_content
  if [[ -f "${cfg_file}" ]]; then
    if diff -q "${cfg_file}" <(echo "${cfg_content}"); then
      logInfo "smartd configuration is already set"
      return 0
    else
      logWarn "smartd configuration is different from the expected one"
    fi
  else
    logWarn "smartd configuration was not found"
  fi

  # If we reach here, we must update the configuration file
  if ! echo "${cfg_content}" >"${cfg_file}"; then
    logError "Failed to write smartd configuration"
    return 1
  else
    logInfo "Updated smartd configuration"
    if ! sd_restart; then
      logError "Failed to restart smartd"
      return 1
    fi
  fi

  return 0
}

# Build the content of the desired config file
#
# Parameters:
#   $1[out]: The content of the file to be created
# Returns:
#   0: Success
#   1: Failure
build_config_file() {
  local __result_file_content="${1}"
  local disks candidates extras fileout

  # Get all disks
  if ! disk_list_drives disks; then
    logError "Failed to list drives"
    return 1
  fi

  # Filter for the candidates that interest us
  candidates=()
  for disk in "${disks[@]}"; do
    if [[ "${disk}" == "sd"* ]]; then
      candidates+=("${disk}")
    elif [[ "${disk}" == "nvme"* ]]; then
      # Strip the "nx" suffix
      # shellcheck disable=SC2001
      disk=$(echo "${disk}" | sed 's|n[0-9]$||')
      candidates+=("${disk}")
    else
      logWarn "Unknown disk: ${disk}"
    fi
  done

  logInfo "Detected the following disks on the system: ${candidates[*]}"

  # See which disks are identified by smartd
  if ! res=$(smartctl --scan); then
    logError "Failed to get smartctl scan"
    return 1
  elif [[ -z "${res}" ]]; then
    logError "No disks found by smartctl"
    return 1
  elif ! res=$(echo "${res}" | awk '{print $1}'); then
    logError "Failed to parse smartctl scan"
    return 1
  elif ! readarray -t disks <<<"${res}"; then
    logError "Failed to parse smartctl scan"
    return 1
  fi

  logTrace "Disks monitored by smartd: ${disks[*]}"

  # Filter out the disks that are not monitored by smartd
  for disk in "${candidates[@]}"; do
    if [[ ! " ${disks[*]} " =~ [[:space:]]/dev/${disk}[[:space:]] ]]; then
      logWarn "Disk ${disk} is not monitored by smartd"
      extras+=("${disk}")
    fi
  done

  # Check we have the expected 3 disks
  if [[ ${#extras[@]} -ne 3 ]]; then
    logWarn "Expected 3 disks in extras, but found ${#extras[@]}: ${extras[*]}"
  fi

  # Build the content of the file
  fileout=$(
    cat <<EOF
# This file was automatically generated during setup
# It lists the disks that are not monitored by smartd by default
# as well as using the DEVICESCAN directive.
DEFAULT ${SD_SMARTD_CONF}
$(for line in "${extras[@]}"; do
      # shellcheck disable=SC2312
      if [[ "${line}" == "sd"* ]]; then
        echo "/dev/${line} -d scsi"
      elif [[ "${line}" == "nvme"* ]]; then
        echo "/dev/${line} -d nvme"
      else
        echo "# Unknown disk: ${line}"
      fi
    done)
DEVICESCAN
EOF
  )

  # Return
  eval "${__result_file_content}='${fileout}'"
  return 0
}

sd_restart() {
  logInfo "Restarting smartd..."
  if ! systemctl restart smartd; then
    logError "Failed to restart smartd"
    return 1
  else
    logInfo "Restarted smartd"
  fi
  return 0
}

sd_test_alerts() {
  # Append to cfg_line for a test
  local cfg_file="/etc/smartmontools/smartd.conf"
  local cfg_line
  local cfg_line_orig

  if [[ -f "${cfg_file}" ]]; then
    if ! cfg_line_orig=$(grep -E "^DEFAULT" "${cfg_file}"); then
      logError "Failed to read smartd configuration"
      return 1
    fi
    cfg_line="${cfg_line_orig} -M test"
    if ! sed -i "s=^DEFAULT.*=${cfg_line}=" "${cfg_file}"; then
      logError "Failed to to configure samrtd for testing"
      return 1
    fi
    logInfo "Appended test to smartd configuration"
  else
    logError "smartd configuration was not found"
    return 1
  fi

  logInfo "Lauching test..."
  if ! sd_restart; then
    logWarn "Failed to restart smartd for conducting the test"
  else
    logInfo "smartd restarted, let the test run for 30 seconds..."
    sleep 60
    logInfo "Test successful. Restoring smartd configuration..."
  fi

  # Restore original configuration
  local success
  sed -i "s=^DEFAULT.*=${cfg_line_orig}=" "${cfg_file}"
  success=$?
  # shellcheck disable=SC2250
  if [[ $success -ne 0 ]]; then
    logError "Failed to restore smartd configuration"
  fi

  if ! sd_restart; then
    success=1
  fi

  # shellcheck disable=SC2248
  return ${success}
}

# Variables loaded externally
if [[ -z "${SYSADMIN}" ]]; then SYSADMIN=""; fi

###########################
###### Startup logic ######
###########################

# Get directory of this script
# https://stackoverflow.com/a/246128
SD_SOURCE=${BASH_SOURCE[0]}
while [[ -L "${SD_SOURCE}" ]]; do # resolve $SD_SOURCE until the file is no longer a symlink
  SD_ROOT=$(cd -P "$(dirname "${SD_SOURCE}")" >/dev/null 2>&1 && pwd)
  SD_SOURCE=$(readlink "${SD_SOURCE}")
  [[ ${SD_SOURCE} != /* ]] && SD_SOURCE=${SD_ROOT}/${SD_SOURCE} # if $SD_SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
SD_ROOT=$(cd -P "$(dirname "${SD_SOURCE}")" >/dev/null 2>&1 && pwd)
SD_ROOT=$(realpath "${SD_ROOT}/../..")

# Determine BPKG's global prefix
if [[ -z "${PREFIX}" ]]; then
  if [[ $(id -u || true) -eq 0 ]]; then
    PREFIX="/usr/local"
  else
    PREFIX="${HOME}/.local"
  fi
fi

# Import dependencies
# shellcheck disable=SC1091
if ! source "${PREFIX}/lib/slf4.sh"; then
  echo "Failed to import slf4.sh"
  exit 1
elif ! source "${PREFIX}/lib/config.sh"; then
  logFatal "Failed to import config.sh"
elif ! config_load "${SD_ROOT}/data/local.env"; then
  logFatal "Failed to load local configuration"
elif [[ -z "${SETUP_DIR}" ]]; then
  logFatal "SETUP_DIR is not set"
elif ! source "${SETUP_DIR}/src/disk.sh"; then
  logFatal "Failed to import os.sh"
fi

if [[ -p /dev/stdin ]] && [[ -z ${BASH_SOURCE[0]} ]]; then
  # This script was piped
  logFatal "This script cannot be piped"
elif [[ ${BASH_SOURCE[0]} != "${0}" ]]; then
  # This script was sourced
  :
else
  # This script was executed
  sd_test_alerts
fi
